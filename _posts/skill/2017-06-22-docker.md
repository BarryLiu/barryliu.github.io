---
layout: post
title: docker 简单使用
category: docker
tags:  docker
keywords: docker
description: docker 使用
---

百度: Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。





[docker命令 ](http://www.runoob.com/docker/docker-command-manual.html)



[Docker与K8s基本概念](https://zhuanlan.zhihu.com/p/53260098)



# docker集装箱
### image镜像

## 安装

``` bash
# 更新下载工具
apt-get update

# 安装docker
apt-get install -y docker.io

```






## 常用命令
	service docker [status|start|stop|restart| ]
	或者
	systemctl docker [status|start|stop|restart| ]

* docker inspect xxx //image name 查看某镜像详细信息

* 查看正运行的镜像 

  > docker ps   //查看正在运行的实例
  >
  > docker ps -all  查看所有运行过的实例
  
* docker images //所有镜像

* docker run 镜像名称 //运行

> -e 指定环境变量

* docker stop 镜像名称 //停止镜像

* docker exec 镜像名称 命令    //进入镜像

> docker exec -it 镜像id   /bin/bash

* docker logs -f 镜像ID	//实时查看log 

> docker logs -f 镜像id 



### 

docker 的镜像与容器都存储在 /var/lib/docker

标准 隔离

镜像 容器 仓库(BUILD SHIP RUN)


## 安装docker
sudo apt-get update
sudo apt-get install docker.io

## 开启docker服务
sudo service docker start
* 查看docker版本

  > docker version

* 查看docker信息

	> docker info

* 查看docker所有镜像

  > docker images

* 搜索名为hello-world的docker镜像

  >  docker search hello-world

* 下载名为hello-word的镜像

  > docker pull hello-world
  >
  > docker run image-id/repository

* 查看docker容器进程

  > docker ps # 默认查询正在运行的，-a 查看所有，-l 查看最新创建的，-n=1 查看最后创建的1个

* 终止容器运行

  > docker stop 容器名或容器ID
  >
  
*  强制终止容器运行
  > docker kill 容器ID
  
* 删除容器

  > docker rm 容器名或容器ID

* 删除所有容器

  > docker rm $(docker ps -a -q)

* 在当前目录创建镜像

  >  docker build -t aaaa:1.0  .
  >
  >  //指定目录dockerfile
  >
  >  docker build -t aaaa:1.0  -f /root/Dockerfile 

* 镜像打tag(类似于提交前的commit)

  > docker tag aaaa:1.0  myregistry/aaa:1.0

* 上传镜像

  > docker push image-id
  >
  > docker push myregistry/aaa:1.0

* 新创建一个镜像

  > docker run -it 要生成的镜像的名称 /bin/bash
  >
  > -t 表示在新容器内指定一个伪终端或终端
  > -i 表示允许我们对容器内的 (STDIN) 进行交互

* 启动或进入容器

  > docker start 容器ID # 启动容器 docker exec -it 容器ID /bin/bash # 进入容器
  > exit # 退出容器

* 提交镜像的修改

  > docker commit -m "修改注释" -a "作者名字" 容器环境ID 生成后的镜像名称

* 删除镜像

  > docker rmi 镜像名/镜像ID
  
* 查看网络

  > docker network ls

* 清理无用的容器和网络

  >  docker system prune -f 清理无用的容器和网络





### 主机与容器之间的文件复制
``` shell
 # 从主机复制到容器
docker cp host_path containerID:container_path
# 从容器复制到主机
docker cp containerID:container_path host_path 

```







### 修改为国内镜像地址，修改 /etc/default/docker 
DOCKER_OPTS="--registry-mirror=https://registry.docker-cn.com"



* 修改为自己的[阿里云镜像](https://cr.console.aliyun.com/cn-shanghai/instances/mirrors)

  > linux修改 /etc/docker/daemon.json文件下的配置后重启,
  >
  > {  "registry-mirrors": ["https://xxxx.mirror.aliyuncs.com"] }

* 登陆阿里云[先建镜像仓库](https://cr.console.aliyun.com/repository/cn-shanghai/workspace1/test1/details)

  > ```
  > docker login --username=15***4072 registry.cn-shanghai.aliyuncs.com
  > ```



* docker 运行镜像仓库

  1. docker官方提供镜像 registry 第一种

     ``` shell
     # pull镜像
     docker pull registry 
     # 运行镜像
     docker run -p 5000:5000 -v /home/registry_images:/var/lib/registry -d rgistry
     
     # 建立完成后修改客户端docker的/etc/docker/daemon.json 镜像仓库配置
     
     ```

  2. docker官方提供镜像 registry 第二种  [自建docker仓库-文章链接](https://blog.csdn.net/hallyz945/article/details/124696972)

     ```shell
     #
     $ docker pull registry:2
     $ docker run -d -v /opt/registry:/var/lib/registry -p 5000:5000 --name myregistry registry:2
     # http://127.0.0.1:5000/v2 返回{}表示正常
     
     # 建立完成后修改客户端docker的/etc/docker/daemon.json 镜像仓库配置
     
     # 验证 (本地先下载好nginx镜像)
     ##1.镜像打包
     docker tag nginx:latest localhost:5000/nginx:latest
     
     ##2.推送镜像
     docker push localhost:5000/nginx:latest
     
     ##3.访问 http://127.0.0.1:5000/v2/_catalog 查看私有仓库目录，可以看到刚上传的镜像了：
     {repositories:["nginx"]}
     
     ##4.下载该镜像
     docker pull localhost:5000/镜像名:版本号
     例如
     docker pull localhost:5000/nginx:latest
     
     ```

      

  3.  harbor 的搭建

     > docker 官方提供的私有仓库 registry，用起来虽然简单 ，但在管理的功能上存在不足。 Harbor是一个用于存储和分发[Docker镜像](https://so.csdn.net/so/search?q=Docker镜像&spm=1001.2101.3001.7020)的企业级Registry服务器，harbor使用的是官方的docker registry(v2命名是distribution)服务去完成。harbor在docker distribution的基础上增加了一些安全、访问控制、管理的功能以满足企业对于镜像仓库的需求。

     第三方的，理论更好用, [地址](https://blog.csdn.net/hallyz945/article/details/124696972)

  

* docker 添加不安全的镜像仓库

  ``` shell
  # vi /etc/docker/daemon.json
  
  { 
    "insecure-registries": ["192.168.xx.xx:port"], # 非安全的仓库地址，自己的镜像仓库
    "registry-mirrors": ["https://xxxx.mirror.aliyuncs.com"] #镜像地址
  }
  # 修改后重启
  systemctl daemon-reload
  ststemctl restart docker
  
  ```

  

### Dockerfile 基本语法与关键字

> FROM,RUN,CMD,ENTRYPOINT, EXPOSE



* FROM 基于基础镜像

* RUN 执行命令

* ADD 拷贝文件

  > ADD ./ /usr/local/xxx   # 将当前目录下所有文件拷贝到指定目录去

* WORKDIR # 设置当前目录为工作目录

  > WORKDIR /usr/local/xxx  

* CMD 运行命令

  > CMD ["python3" , "./main.py"] 

* EXPOSE 对外暴露端口命令



 Dockerfile 常用指令

| 指令       | 语法                                            |                                                         说明 |
| ---------- | ----------------------------------------------- | -----------------------------------------------------------: |
| FROM       | `FROM <image>:<tag>`                            | 指明构建的新镜像是来自于哪个基础镜像，如果没有选择`tag`，那么默认值为`latest` |
| MAINTAINER | `MAINTAINER <name>`                             | 指明镜像维护者及其联系方式（一般是邮箱地址）。官方说明已过时，推荐使用`LABEL` |
| LABEL      | `LABEL <key>=<value> ...`                       |        功能是为镜像指定标签。也可以使用`LABEL`来指定镜像作者 |
| RUN        | `RUN <command>`                                 | 构建镜像时运行的`Shell`命令，比如构建的新镜像中我们想在`/usr/local`目录下创建一个`java`目录 |
| ADD        | `ADD <src>... <dest>`                           | 拷贝文件或目录到镜像中。src 可以是一个本地文件，还可以是一个`url`。然后自动下载和解压 |
| COPY       | `COPY <src>... <dest>`                          | 拷贝文件或目录到镜像中。用法同 ADD，只是不支持自动下载和解压 |
| EXPOSE     | `EXPOSE <port> [<port>/<protocol>...]`          | 暴露容器运行时的监听端口给外部，可以指定端口是监听 TCP 还是 UDP，如果未指定协议，则默认为 TCP |
| ENV        | `ENV <key>=<value> ...`                         |                                           设置容器内环境变量 |
| CMD        | `CMD ["executable","param1","param2"]`          | 启动容器时执行的`Shell`命令。在`Dockerfile`中只能有一条`CMD`指令。如果设置了多条`CMD`，只有最后一条会生效 |
| ENTRYPOINT | `ENTRYPOINT ["executable", "param1", "param2"]` | 启动容器时执行的 Shell 命令，同 CMD 类似，不会被 docker run 命令行指定的参数所覆盖，如果设置了多条`ENTRYPOINT`，只有最后一条会生效 |
| WORKDIR    | `WORKDIR param`                                 |        为 RUN、CMD、ENTRYPOINT 以及 COPY 和 AND 设置工作目录 |
| VOLUME     | `VOLUME ["param"]`                              | 指定容器挂载点到宿主机自动生成的目录或其他容器。一般的使用场景为需要持久化存储数据时 |





## 容器编排 docker-compose

> docker-compose.yml 将多个镜像一起处理

[参考文档](https://huaweicloud.csdn.net/63311428d3efff3090b51866.html?spm=1001.2101.3001.6650.5&utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~activity-5-118558700-blog-119191532.pc_relevant_3mothn_strategy_recovery&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~activity-5-118558700-blog-119191532.pc_relevant_3mothn_strategy_recovery&utm_relevant_index=6)

[参考文档2](https://blog.csdn.net/weixin_43420255/article/details/106495197)

[参考文档3](https://blog.csdn.net/tabingbuxiaode/article/details/126365978)

[参考文档4](http://www.rssso.com/news/E2BCDD6305979CB8)

## 子命令



| 命令                   | 描述                                        |
| ---------------------- | ------------------------------------------- |
| docker-compose build   | 构建或重建服务                              |
| docker-compose convert | 将compose文件转换为平台的规范格式           |
| docker-compose cp      | 在服务容器和本地文件系统之间复制文件/文件夹 |
| docker-compose create  | 为服务创建容器                              |
| docker-compose down    | 停止并移除容器，网络                        |
| docker-compose events  | 从容器中接收实时事件。                      |
| docker-compose exec    | 在正在运行的容器中执行命令。                |
| docker-compose images  | 列出容器使用的镜像                          |
| docker-compose kill    | 强制停止服务容器。                          |
| docker-compose logs    | 查看容器的输出                              |
| docker-compose ls      | 运行compose项目的列表                       |
| docker-compose pause   | 暂停服务                                    |
| docker-compose port    | 输出端口绑定的公共端口。                    |
| docker-compose ps      | 列出容器列表                                |
| docker-compose pull    | 拉取服务镜像                                |
| docker-compose push    | 推送服务镜像                                |
| docker-compose restart | 重启服务容器                                |
| docker-compose rm      | 移除已停止的服务容器                        |
| docker-compose run     | 在服务上运行一次性命令。                    |
| docker-compose start   | 开始服务                                    |
| docker-compose stop    | 停止服务                                    |
| docker-compose top     | 显示正在运行的进程                          |
| docker-compose unpause | 取消暂停的服务                              |
| docker-compose up      | 创建并启动容器                              |
| docker-compose version | 显示Docker Compose的版本信息                |



[docker-compose up 与 docker stack deploy 区别](https://blog.csdn.net/m0_67402564/article/details/124171654)





[docker 三剑客](https://blog.csdn.net/qq_47295318/article/details/123262866)

[参考地址](https://blog.51cto.com/key3feng/5204096)

[参考地址2](https://zhuanlan.zhihu.com/p/182198031)

[参考地址3 docker swarm集群](https://www.bbsmax.com/A/Ae5RYqYYJQ/)

* docker-compose 多个容器编排
* docker-machine  命令行工具
* docker-swarm 集群



初始化swarm集群，用`--listen-addr`指定监听的ip与端口

docker swarm init --listen-addr 0.0.0.0



查看集群节点情况

docker node ls



查看加入为swarm manager的token

docker swarm join-token manager



脱离集群

docker swarm leave



查看原有网络

docker network ls



# 安装k8s

[参考地址](https://www.jianshu.com/p/f2d4dd4d1fb1)

[参考地址2](https://www.imooc.com/video/19158)




* apt-get 翻墙安装

  ```bash
  新建翻墙配置文件,内容为下面三行:
  Acquire::http::proxy "http://ip:端口/"
  Acquire::ftp::proxy "ftp://ip:端口/"
  Acquire::https::proxy "https://ip:端口/"
  
  apt-get -c 文件名(翻墙代理如果需要) install -y xxxx 
   
  
  ```

  



``` shell
# 更新安装器
apt-get install update 

#  使得 apt 支持 ssl 传输
apt-get install apt-transport-https
# 如报错不能安装则重装apt-get(错误提示:The package lists or status file could not be parsed or opened.)
# sudo rm -vf /var/lib/apt/lists/*
# sudo apt-get update

# 设置linux代理命令，echo $http_proxy 验证成功与否(需要科学上网)
# export http_proxy=192.168.*.*:1087   && export https_proxy =http_proxy=192.168.*.*:1087



# 安装命令
apt-get install -y kubelet kubeadm kubectl

# 禁止命令更新: apt-mark hold kubelet kubeadm kubectl



```







#### k8s master初始化



#### 禁用虚拟内存

* 方式1(重启后消失)

  > swapoff -a 

* 方式2，编辑/etc/fstab 配置,注释第二行文件，然后重启

  ``` shell
  sudo vi /etc/fstab
  ###编辑/etc/fstab 配置,注释第二行文件
  UUID=e2048966-750b-4795-a9a2-7b477d6681bf /   ext4    errors=remount-ro 0    1
  # /dev/fd0        /media/floppy0  auto    rw,user,noauto,exec,utf8 0       0
  
  #重启
  reboot
  ```

  

### k8s master初始化

``` shell

#禁用虚拟内存
swapoff -a 

#初始化
# 某些版本如果cpu小于一核会初始化失败,添加后面参数避免验证失败 --ignore-preflight-errors=NumCPU  
kubeadmin init --pod-network-cidr=xxxxxxx/xx --ignore-preflight-errors=NumCPU

#
kubeadm init \
--apiserver-advertise-address=192.168.56.11(master节点的服务器ip) \
--image-repository registry.aliyuncs.com/google_containers \
--pod-network-cidr=10.244.0.0/16


```



``` shell

# 检查node是不是ready状态
kubectl get node 

# 检查所有pod是不是正常
kubectl get po --all-namespace -o wide 

# 如果pod不是running状态,则查看该pod：  kubectl describe pod xxxx -n kube-system ,可能是镜像无法下载导致,如果是手动再node上pullimage
# 然后在master上删除对应的pod, k8s会自动重新调度
# 删除命令: kubectl delete pod xxx -n kube-system

```





* 设置一台服务器到另一台服务器免密登录

  ``` shell
  # 生产密钥和公钥 (默认名字是id_rsa和id_rsa.pub)
  ssh-keygen -t rsa 
  
  # 将公钥发送到另一台服务器
  ssh-copy-id -i ~/.ssh/id_rsa.pub  root@otherip  
  
  #验证,不用输入密码能登录代表好了 
  ssh root@otherip 
  
  
  ```



* 查看k8s运行的应用

  > kubectl get services --all-namespaces 

* 配置脚本

  ``` shell
  #### deploy_docker.sh 
  
  #!/bin/sh
  #maven01 $workspace $jarname
  # ${projectName} ${docker_path} ${jarName}
  
  set -e
  projectName=$1
  docker_path=$2
  appName=$3
  
  #user_name = 
  #password=
  
  tag=$(data +%s)
  
  # 镜像仓库地址
  server_path=192.168.22.22:5000
  target_image=${projectName}:${tag}
  #${BUILD_NUMBER}
  echo ${target_image}
  
  cd ${docker_path}
  
  # 构建docker镜像
  docker build --build-arg app=${appName } -t ${target_image } . 
  
  # 镜像打tag 
  docker tag ${target_image } ${server_path}/${projectName}
  echo The name of image is "${server_path}\/${target_image}"
  
  #推送镜像到仓库
  docker push ${server_path}/${projectName}:latest
  
  # 删除镜像
  docker rmi -f $(docker images | grep ${projectName} | grep {tag} | awk '{print $3}' | head -n 1)
  
  
  
  
  
  
  
  
  
  ```



* 运行命令

  ``` shell
  
  # 运行应用
  kubectl apply -f kube.yaml 
  
  # 查看所有运行的service
  kubel get sevices --all-namespace
  
  
  ```

  







# jenkins+ docker+kubernates



1. jenkins 打包出jar文件

   1. 执行shell 生成新的镜像推送到镜像服务器

      ``` shell
      #!/bin/sh
      
      jarName=xxxx.jar
      jarFolder=xx
      projectName=xx
      
      docker_path=${WORKSPACE}
      
      cp ${WORKSPACE}/target/${jarName}  ${docker_path}
      
      # 执行镜像打包命令，命令内容上面有
      sh /root/docker_dir/deploy_docker.sh  ${projectName} ${docker_path} ${jarName}
      
      
      ```

   2. 再执行shell, 将yaml配置文件拷贝到k8s master 上面运行应用

      ``` shell
      
      set -e
      echo ok
      echo ${WORKSPACE }
      docker_path=${WORKSPACE }
      
      # 将k8s的yaml配置文件拷贝过去
      scp ${WORKSPACE}/*.yaml k8smasterhostip:/root/
      
      # 远程执行命令部署k8s应用
      ssh k8smasterhostip '/opt/bin/kubectl apply -f /root/kube.yaml'
      ssh k8smasterhostip '/opt/bin/kubectl get svc|grep maven'
      
      
      ```

      

2. 编译后执行docker打包成镜像命令

3. 打包后推送镜像

