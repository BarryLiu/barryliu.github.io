# 签名证书





## 1. 签名生成keystore 

keytool -importkeystore -srcstoretype JKS -srckeystore test.jks -deststoretype PKCS12 -destkeystore test.keystore



签名文件 kestore 和 jks 的在作用上基本上没有太大区别，主要是生成来源不一样，它们是由不同的 IDE 生成，keystore 文件一般是由 Eclipce 或 dos 命令行生成，而 jks 一般是在 Android studio 上自动生成。



### keytool签出keystore文件

```shell
"D:\softs\jdk\jdk1.8.0_111\jre\bin\keytool.exe"  -genkey -dname  cn=测试,ou=11,o=22,l=33,st=44,c=  -alias 982732_6317 -keyalg RSA -keypass 982732 -storepass 982732 -keystore D:\ruoyi\uploadPath\signfile\113\982732_6317_1753429314353.keystore -validity 36500

```



### keystored提取出 pk8和 x509.pem

``` shell
# 1.使用命令 keystore生成中间.p12 文件 ： keytool   -importkeystore -srckeystore debug.keystore   -destkeystore tmp.p12 -srcstoretype JKS  -deststoretype PKCS12


"D:\softs\jdk\jdk1.8.0_111\jre\bin\keytool.exe"  -importkeystore -srckeystore D:\ruoyi\uploadPath\signfile\113\982732_6317_1753429314353.keystore -srcstorepass 982732 -destkeystore D:\ruoyi\uploadPath\signfile\113\982732_6317_1753429314353.p12 -deststorepass 982732 -srcstoretype JKS  -deststoretype PKCS12


# 2. .p12 生成 rsa文件 ：   openssl  pkcs12 -in tmp.p12 -nodes -passin pass:zxc123 -out tmp.rsa.pem

C:\Program Files\OpenSSL-Win64\bin\openssl.exe pkcs12 -in D:\ruoyi\uploadPath\signfile\113\982732_6317_1753429314353.p12 -nocerts -nodes -passin pass:982732 -out D:\ruoyi\uploadPath\signfile\113\982732_6317_1753429314353.rsa.pem

# 3. 生成x509.pem ,执行之后字符串处理将-----BEGIN CERTIFICATE-----前面的内容都不要
C:\Program Files\OpenSSL-Win64\bin\openssl.exe  pkcs12 -in D:\ruoyi\uploadPath\signfile\113\982732_6317_1753429314353.p12 -clcerts -nokeys -nodes -passin pass:982732 -out D:\ruoyi\uploadPath\signfile\113\982732_6317_1753429314353.x509.pem.tem

# 4. 生成pk8
openssl  pkcs8 -topk8 -outform DER -in xxx.rsa.pem -inform PEM -out xxx.pk8


```





### jks 转化为 keystore

```bash
keytool -importkeystore -srcstoretype JKS -srckeystore test.jks -deststoretype PKCS12 -destkeystore test.keystore
```



### keystore 转化为 jks  

```bash
keytool -v -importkeystore -srcstoretype PKCS12 -srckeystore test.keystore -deststoretype JKS -destkeystore test.jks -srcstorepass 源密钥库口令 -deststorepass 目标密钥库口令
```





### 签名apk命令

``` shell
apk签名命令, 命令：
java -jar signapk.jar xxx.pem xxx.pk8 app.apk app_signed.apk

```



### 验证签名命令

``` shell
命令 ： jarsigner -verify xxx.apk
返回：“jar已验证” 表示验证成功，被篡改过会列出改动过的文件


```

















## 2. 生成签名RSA再生成证书链并签名





```


# CSR(Certificate Signing Request) ,请求文件
# 数字证书有多重编码格式: eg: CER(Canonical Encoding Rules，规范编码格式),DER(Distinguished Encoding Rule,卓越编码格式),本处使用cer
# CRT() per格式的证书
# CER 证书


# 查看证书中内容
openssl req -in targetCA.csr -text

# 查看X.509证书中的公钥
openssl x509 -in certificate.cer -pubkey -noout
openssl x509 -in certificate.cer -text -noout


========================================================================================
# 生成根证书
openssl genrsa -out rootCA.key 2048
openssl req -new -key rootCA.key -out rootCA.csr -subj "/C=CN/ST=Shanghai/L=Shanghai/O=xchengtech/OU=xchengtech/CN=www.xc-tech.com"
openssl x509 -req -days 365000 -in rootCA.csr -signkey rootCA.key -out rootCA.crt



# 生成中间证书
openssl genrsa -out intermediate.key 2048
openssl req -new -key intermediate.key -out intermediate.csr -subj "/C=CN/ST=Shanghai/L=Shanghai/O=xchengtech/OU=xchengtech/CN=intermediate.xc-tech.com"
openssl x509 -req -days 365000 -in intermediate.csr -CA rootCA.crt -CAkey rootCA.key -CAcreateserial -out intermediate.crt



# 生成子证书(xcheng)(对外顶级证书)
openssl genrsa -out server.key 2048
openssl req -new -key server.key -out server.csr  -subj "/C=CN/ST=Shanghai/L=Shanghai/O=xchengtech/OU=apex/CN=xc-tech.com"
openssl x509 -req -days 365000 -in server.csr -CA intermediate.crt -CAkey intermediate.key -CAcreateserial -out server.crt


# 生成顶级证书对外中间证书 (xcheng)
openssl genrsa -out server_intermediate.key 2048
openssl req -new -key server_intermediate.key -out server_intermediate.csr  -subj "/C=CN/ST=Shanghai/L=Shanghai/O=xchengtech/OU=apex/CN=xc-tech.com"
openssl x509 -req -days 365000 -in server_intermediate.csr -CA server.crt -CAkey server.key -CAcreateserial -out server_intermediate.crt


## 验证证书
cat rootCA.crt intermediate.crt server.crt server_intermediate.crt > chain.crt
openssl verify -CAfile rootCA.crt chain.crt

## 生成公钥
openssl x509 -pubkey -noout -in rootCA.crt > rootCA.pem
openssl x509 -pubkey -noout -in intermediate.crt > intermediate.pem
openssl x509 -pubkey -noout -in server.crt > server.pem
openssl x509 -pubkey -noout -in server_intermediate.crt > server_intermediate.pem

## 再以下生成规则一样



```



### rsa私钥对和证书转 .509.pem和 .pk8



####  1. .crt证书转 .x509.pem

``` shell
其实它们内容是一样的,直接复制或者用命令转没啥区别
# 直接复制，
cp fastboy.crt fastboy_1.x509.pem

# 或者从现有的 PEM 文件提取
openssl x509 -in fastboy.crt -out fastboy_1.x509.pem
```

####  2. 提取 .pk8 文件（PKCS#8 格式的私钥）（DER 格式的 PKCS#8 文件（二进制格式））

``` shell
# 从 RSA 私钥直接生成 DER 格式的 PKCS#8 文件
openssl pkcs8 -topk8 -inform PEM -outform DER -nocrypt -in private.key -out private.pk8

```



### 3. 签文件

``` 

java -jar signapk.jar fastboy_1.x509.pem fastboy_1.pk8 test.zip test_signed_fastboy.zip


```

